//
// AUTO-GENERATED FILE, DO NOT MODIFY!
//
// @dart=2.18

// ignore_for_file: unused_element, unused_import
// ignore_for_file: always_put_required_named_parameters_first
// ignore_for_file: constant_identifier_names
// ignore_for_file: lines_longer_than_80_chars

part of openapi.api;

class PaymentMethodDetailsCardPresentReceipt {
  /// Returns a new [PaymentMethodDetailsCardPresentReceipt] instance.
  PaymentMethodDetailsCardPresentReceipt({
    this.accountType,
    this.applicationCryptogram,
    this.applicationPreferredName,
    this.authorizationCode,
    this.authorizationResponseCode,
    this.cardholderVerificationMethod,
    this.dedicatedFileName,
    this.terminalVerificationResults,
    this.transactionStatusInformation,
  });

  /// The type of account being debited or credited
  PaymentMethodDetailsCardPresentReceiptAccountTypeEnum? accountType;

  /// The Application Cryptogram, a unique value generated by the card to authenticate the transaction with issuers.
  String? applicationCryptogram;

  /// The Application Identifier (AID) on the card used to determine which networks are eligible to process the transaction. Referenced from EMV tag 9F12, data encoded on the card's chip.
  String? applicationPreferredName;

  /// Identifier for this transaction.
  String? authorizationCode;

  /// EMV tag 8A. A code returned by the card issuer.
  String? authorizationResponseCode;

  /// Describes the method used by the cardholder to verify ownership of the card. One of the following: `approval`, `failure`, `none`, `offline_pin`, `offline_pin_and_signature`, `online_pin`, or `signature`.
  String? cardholderVerificationMethod;

  /// Similar to the application_preferred_name, identifying the applications (AIDs) available on the card. Referenced from EMV tag 84.
  String? dedicatedFileName;

  /// A 5-byte string that records the checks and validations that occur between the card and the terminal. These checks determine how the terminal processes the transaction and what risk tolerance is acceptable. Referenced from EMV Tag 95.
  String? terminalVerificationResults;

  /// An indication of which steps were completed during the card read process. Referenced from EMV Tag 9B.
  String? transactionStatusInformation;

  @override
  bool operator ==(Object other) => identical(this, other) || other is PaymentMethodDetailsCardPresentReceipt &&
    other.accountType == accountType &&
    other.applicationCryptogram == applicationCryptogram &&
    other.applicationPreferredName == applicationPreferredName &&
    other.authorizationCode == authorizationCode &&
    other.authorizationResponseCode == authorizationResponseCode &&
    other.cardholderVerificationMethod == cardholderVerificationMethod &&
    other.dedicatedFileName == dedicatedFileName &&
    other.terminalVerificationResults == terminalVerificationResults &&
    other.transactionStatusInformation == transactionStatusInformation;

  @override
  int get hashCode =>
    // ignore: unnecessary_parenthesis
    (accountType == null ? 0 : accountType!.hashCode) +
    (applicationCryptogram == null ? 0 : applicationCryptogram!.hashCode) +
    (applicationPreferredName == null ? 0 : applicationPreferredName!.hashCode) +
    (authorizationCode == null ? 0 : authorizationCode!.hashCode) +
    (authorizationResponseCode == null ? 0 : authorizationResponseCode!.hashCode) +
    (cardholderVerificationMethod == null ? 0 : cardholderVerificationMethod!.hashCode) +
    (dedicatedFileName == null ? 0 : dedicatedFileName!.hashCode) +
    (terminalVerificationResults == null ? 0 : terminalVerificationResults!.hashCode) +
    (transactionStatusInformation == null ? 0 : transactionStatusInformation!.hashCode);

  @override
  String toString() => 'PaymentMethodDetailsCardPresentReceipt[accountType=$accountType, applicationCryptogram=$applicationCryptogram, applicationPreferredName=$applicationPreferredName, authorizationCode=$authorizationCode, authorizationResponseCode=$authorizationResponseCode, cardholderVerificationMethod=$cardholderVerificationMethod, dedicatedFileName=$dedicatedFileName, terminalVerificationResults=$terminalVerificationResults, transactionStatusInformation=$transactionStatusInformation]';

  Map<String, dynamic> toJson() {
    final json = <String, dynamic>{};
    if (this.accountType != null) {
      json[r'account_type'] = this.accountType;
    } else {
      json[r'account_type'] = null;
    }
    if (this.applicationCryptogram != null) {
      json[r'application_cryptogram'] = this.applicationCryptogram;
    } else {
      json[r'application_cryptogram'] = null;
    }
    if (this.applicationPreferredName != null) {
      json[r'application_preferred_name'] = this.applicationPreferredName;
    } else {
      json[r'application_preferred_name'] = null;
    }
    if (this.authorizationCode != null) {
      json[r'authorization_code'] = this.authorizationCode;
    } else {
      json[r'authorization_code'] = null;
    }
    if (this.authorizationResponseCode != null) {
      json[r'authorization_response_code'] = this.authorizationResponseCode;
    } else {
      json[r'authorization_response_code'] = null;
    }
    if (this.cardholderVerificationMethod != null) {
      json[r'cardholder_verification_method'] = this.cardholderVerificationMethod;
    } else {
      json[r'cardholder_verification_method'] = null;
    }
    if (this.dedicatedFileName != null) {
      json[r'dedicated_file_name'] = this.dedicatedFileName;
    } else {
      json[r'dedicated_file_name'] = null;
    }
    if (this.terminalVerificationResults != null) {
      json[r'terminal_verification_results'] = this.terminalVerificationResults;
    } else {
      json[r'terminal_verification_results'] = null;
    }
    if (this.transactionStatusInformation != null) {
      json[r'transaction_status_information'] = this.transactionStatusInformation;
    } else {
      json[r'transaction_status_information'] = null;
    }
    return json;
  }

  /// Returns a new [PaymentMethodDetailsCardPresentReceipt] instance and imports its values from
  /// [value] if it's a [Map], null otherwise.
  // ignore: prefer_constructors_over_static_methods
  static PaymentMethodDetailsCardPresentReceipt? fromJson(dynamic value) {
    if (value is Map) {
      final json = value.cast<String, dynamic>();

      // Ensure that the map contains the required keys.
      // Note 1: the values aren't checked for validity beyond being non-null.
      // Note 2: this code is stripped in release mode!
      assert(() {
        requiredKeys.forEach((key) {
          assert(json.containsKey(key), 'Required key "PaymentMethodDetailsCardPresentReceipt[$key]" is missing from JSON.');
          assert(json[key] != null, 'Required key "PaymentMethodDetailsCardPresentReceipt[$key]" has a null value in JSON.');
        });
        return true;
      }());

      return PaymentMethodDetailsCardPresentReceipt(
        accountType: PaymentMethodDetailsCardPresentReceiptAccountTypeEnum.fromJson(json[r'account_type']),
        applicationCryptogram: mapValueOfType<String>(json, r'application_cryptogram'),
        applicationPreferredName: mapValueOfType<String>(json, r'application_preferred_name'),
        authorizationCode: mapValueOfType<String>(json, r'authorization_code'),
        authorizationResponseCode: mapValueOfType<String>(json, r'authorization_response_code'),
        cardholderVerificationMethod: mapValueOfType<String>(json, r'cardholder_verification_method'),
        dedicatedFileName: mapValueOfType<String>(json, r'dedicated_file_name'),
        terminalVerificationResults: mapValueOfType<String>(json, r'terminal_verification_results'),
        transactionStatusInformation: mapValueOfType<String>(json, r'transaction_status_information'),
      );
    }
    return null;
  }

  static List<PaymentMethodDetailsCardPresentReceipt> listFromJson(dynamic json, {bool growable = false,}) {
    final result = <PaymentMethodDetailsCardPresentReceipt>[];
    if (json is List && json.isNotEmpty) {
      for (final row in json) {
        final value = PaymentMethodDetailsCardPresentReceipt.fromJson(row);
        if (value != null) {
          result.add(value);
        }
      }
    }
    return result.toList(growable: growable);
  }

  static Map<String, PaymentMethodDetailsCardPresentReceipt> mapFromJson(dynamic json) {
    final map = <String, PaymentMethodDetailsCardPresentReceipt>{};
    if (json is Map && json.isNotEmpty) {
      json = json.cast<String, dynamic>(); // ignore: parameter_assignments
      for (final entry in json.entries) {
        final value = PaymentMethodDetailsCardPresentReceipt.fromJson(entry.value);
        if (value != null) {
          map[entry.key] = value;
        }
      }
    }
    return map;
  }

  // maps a json object with a list of PaymentMethodDetailsCardPresentReceipt-objects as value to a dart map
  static Map<String, List<PaymentMethodDetailsCardPresentReceipt>> mapListFromJson(dynamic json, {bool growable = false,}) {
    final map = <String, List<PaymentMethodDetailsCardPresentReceipt>>{};
    if (json is Map && json.isNotEmpty) {
      // ignore: parameter_assignments
      json = json.cast<String, dynamic>();
      for (final entry in json.entries) {
        map[entry.key] = PaymentMethodDetailsCardPresentReceipt.listFromJson(entry.value, growable: growable,);
      }
    }
    return map;
  }

  /// The list of required keys that must be present in a JSON.
  static const requiredKeys = <String>{
  };
}

/// The type of account being debited or credited
class PaymentMethodDetailsCardPresentReceiptAccountTypeEnum {
  /// Instantiate a new enum with the provided [value].
  const PaymentMethodDetailsCardPresentReceiptAccountTypeEnum._(this.value);

  /// The underlying value of this enum member.
  final String value;

  @override
  String toString() => value;

  String toJson() => value;

  static const checking = PaymentMethodDetailsCardPresentReceiptAccountTypeEnum._(r'checking');
  static const credit = PaymentMethodDetailsCardPresentReceiptAccountTypeEnum._(r'credit');
  static const prepaid = PaymentMethodDetailsCardPresentReceiptAccountTypeEnum._(r'prepaid');
  static const unknown = PaymentMethodDetailsCardPresentReceiptAccountTypeEnum._(r'unknown');

  /// List of all possible values in this [enum][PaymentMethodDetailsCardPresentReceiptAccountTypeEnum].
  static const values = <PaymentMethodDetailsCardPresentReceiptAccountTypeEnum>[
    checking,
    credit,
    prepaid,
    unknown,
  ];

  static PaymentMethodDetailsCardPresentReceiptAccountTypeEnum? fromJson(dynamic value) => PaymentMethodDetailsCardPresentReceiptAccountTypeEnumTypeTransformer().decode(value);

  static List<PaymentMethodDetailsCardPresentReceiptAccountTypeEnum> listFromJson(dynamic json, {bool growable = false,}) {
    final result = <PaymentMethodDetailsCardPresentReceiptAccountTypeEnum>[];
    if (json is List && json.isNotEmpty) {
      for (final row in json) {
        final value = PaymentMethodDetailsCardPresentReceiptAccountTypeEnum.fromJson(row);
        if (value != null) {
          result.add(value);
        }
      }
    }
    return result.toList(growable: growable);
  }
}

/// Transformation class that can [encode] an instance of [PaymentMethodDetailsCardPresentReceiptAccountTypeEnum] to String,
/// and [decode] dynamic data back to [PaymentMethodDetailsCardPresentReceiptAccountTypeEnum].
class PaymentMethodDetailsCardPresentReceiptAccountTypeEnumTypeTransformer {
  factory PaymentMethodDetailsCardPresentReceiptAccountTypeEnumTypeTransformer() => _instance ??= const PaymentMethodDetailsCardPresentReceiptAccountTypeEnumTypeTransformer._();

  const PaymentMethodDetailsCardPresentReceiptAccountTypeEnumTypeTransformer._();

  String encode(PaymentMethodDetailsCardPresentReceiptAccountTypeEnum data) => data.value;

  /// Decodes a [dynamic value][data] to a PaymentMethodDetailsCardPresentReceiptAccountTypeEnum.
  ///
  /// If [allowNull] is true and the [dynamic value][data] cannot be decoded successfully,
  /// then null is returned. However, if [allowNull] is false and the [dynamic value][data]
  /// cannot be decoded successfully, then an [UnimplementedError] is thrown.
  ///
  /// The [allowNull] is very handy when an API changes and a new enum value is added or removed,
  /// and users are still using an old app with the old code.
  PaymentMethodDetailsCardPresentReceiptAccountTypeEnum? decode(dynamic data, {bool allowNull = true}) {
    if (data != null) {
      switch (data) {
        case r'checking': return PaymentMethodDetailsCardPresentReceiptAccountTypeEnum.checking;
        case r'credit': return PaymentMethodDetailsCardPresentReceiptAccountTypeEnum.credit;
        case r'prepaid': return PaymentMethodDetailsCardPresentReceiptAccountTypeEnum.prepaid;
        case r'unknown': return PaymentMethodDetailsCardPresentReceiptAccountTypeEnum.unknown;
        default:
          if (!allowNull) {
            throw ArgumentError('Unknown enum value to decode: $data');
          }
      }
    }
    return null;
  }

  /// Singleton [PaymentMethodDetailsCardPresentReceiptAccountTypeEnumTypeTransformer] instance.
  static PaymentMethodDetailsCardPresentReceiptAccountTypeEnumTypeTransformer? _instance;
}


